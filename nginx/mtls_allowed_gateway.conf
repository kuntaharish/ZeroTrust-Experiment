# ------------------------------
# Zero Trust Gateway (mTLS + allowlist)
# 12 services: a..l
# Segments (unequal sizes):
#   seg1 (2):  a,b
#   seg2 (4):  c,d,e,f
#   seg3 (6):  g,h,i,j,k,l
# ------------------------------

# Docker DNS (optional but good hygiene)
resolver 127.0.0.11 valid=30s ipv6=off;

# Extract client CN from the full subject DN.
# Example: $ssl_client_s_dn = "CN=service-a"
map $ssl_client_s_dn $client_cn {
    default "";
    ~CN=([^,/]+) $1;
}

# Map CN -> segment
map $client_cn $segment {
    default     "unknown";

    "service-a" "seg1";
    "service-b" "seg1";

    "service-c" "seg2";
    "service-d" "seg2";
    "service-e" "seg2";
    "service-f" "seg2";

    "service-g" "seg3";
    "service-h" "seg3";
    "service-i" "seg3";
    "service-j" "seg3";
    "service-k" "seg3";
    "service-l" "seg3";
}

# Authorization matrix: segment -> which targets allowed
# $target is set per location below (/a/, /b/, ... /l/)
map "$segment:$target" $allowed {
    default 0;

    # seg1: a,b
    "seg1:a" 1;
    "seg1:b" 1;

    # seg2: c,d,e,f
    "seg2:c" 1;
    "seg2:d" 1;
    "seg2:e" 1;
    "seg2:f" 1;

    # seg3: g,h,i,j,k,l
    "seg3:g" 1;
    "seg3:h" 1;
    "seg3:i" 1;
    "seg3:j" 1;
    "seg3:k" 1;
    "seg3:l" 1;
}

server {
    listen 443 ssl;
    server_name localhost;

    # Server TLS cert
    ssl_certificate     /etc/nginx/certs/server.crt;
    ssl_certificate_key /etc/nginx/certs/server.key;

    # Client auth (mTLS)
    ssl_client_certificate /etc/nginx/certs/ca.crt;
    ssl_verify_client on;
    ssl_verify_depth 2;

    # Optional: better warm behavior (session reuse)
    ssl_session_cache   shared:SSL:10m;
    ssl_session_timeout 10m;

    keepalive_timeout  75s;
    keepalive_requests 1000;

    # Debug headers (great for reviewer screenshots)
    add_header X-Debug-Client-DN $ssl_client_s_dn always;
    add_header X-Debug-Client-CN $client_cn always;
    add_header X-Debug-Segment   $segment always;
    add_header X-Debug-Allowed   $allowed always;

    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_set_header X-Workload-Id $client_cn;

    location = /health {
        return 200 "ok\n";
    }

    location /a/ { set $target "a"; if ($allowed = 0) { return 403; } proxy_pass http://service-a:5000/; }
    location /b/ { set $target "b"; if ($allowed = 0) { return 403; } proxy_pass http://service-b:5000/; }
    location /c/ { set $target "c"; if ($allowed = 0) { return 403; } proxy_pass http://service-c:5000/; }
    location /d/ { set $target "d"; if ($allowed = 0) { return 403; } proxy_pass http://service-d:5000/; }
    location /e/ { set $target "e"; if ($allowed = 0) { return 403; } proxy_pass http://service-e:5000/; }
    location /f/ { set $target "f"; if ($allowed = 0) { return 403; } proxy_pass http://service-f:5000/; }
    location /g/ { set $target "g"; if ($allowed = 0) { return 403; } proxy_pass http://service-g:5000/; }
    location /h/ { set $target "h"; if ($allowed = 0) { return 403; } proxy_pass http://service-h:5000/; }
    location /i/ { set $target "i"; if ($allowed = 0) { return 403; } proxy_pass http://service-i:5000/; }
    location /j/ { set $target "j"; if ($allowed = 0) { return 403; } proxy_pass http://service-j:5000/; }
    location /k/ { set $target "k"; if ($allowed = 0) { return 403; } proxy_pass http://service-k:5000/; }
    location /l/ { set $target "l"; if ($allowed = 0) { return 403; } proxy_pass http://service-l:5000/; }
}
